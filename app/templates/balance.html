{% extends "base.html" %}

{% block title %}Line Balance{% endblock %}

{% block header_title %}Line Balance{% endblock %}

{% block content %}
<div class="game-container">
    <h1>Line Balance</h1>
    <p>Drag the ball along the line!</p>
    <div class="game-area">
        <canvas id="trailCanvas"></canvas>
        <div class="ball"></div>
    </div>
    <div class="game-info">
        <div id="score">Score: 0</div>
        <div id="timer">Time: 20s</div>
        <div id="status"></div>
    </div>
    <button id="startButton">Start Game</button>
</div>

<style>
.game-container {
    max-width: 800px;
    margin: 6rem auto 2rem;
    padding: 1rem;
    background: var(--card-background);
    border-radius: 1.5rem;
    box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1);
    text-align: center;
}

.game-area {
    width: 100%;
    padding-bottom: 66.67%; /* 3:2 aspect ratio */
    margin: 1rem auto;
    background: #f8f5ff;
    border: 2px solid #333;
    border-radius: 1rem;
    position: relative;
    overflow: hidden;
}

#trailCanvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

.ball {
    width: 24px;
    height: 24px;
    background: #4CAF50;
    border-radius: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
    cursor: grab;
    z-index: 2;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
    left: 10%;
    top: 50%;
}

.ball:active {
    cursor: grabbing;
    box-shadow: 0 0 15px rgba(76, 175, 80, 0.8);
}

#startButton {
    padding: 12px 24px;
    font-size: 18px;
    background: linear-gradient(135deg, #8B5CF6, #EC4899);
    color: white;
    border: none;
    border-radius: 25px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    width: 80%;
    max-width: 300px;
    margin: 1rem auto;
    display: block;
}

#startButton:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3);
}

.game-info {
    display: flex;
    justify-content: space-around;
    margin: 1rem auto;
    font-size: 1.2rem;
    max-width: 400px;
    padding: 0 1rem;
}

#timer {
    color: #2196F3;
    font-weight: bold;
}

#score {
    color: #4CAF50;
    font-weight: bold;
}

#status {
    color: #f44336;
}

.game-over {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(244, 67, 54, 0.9);
    color: white;
    padding: 1rem;
    border-radius: 1rem;
    font-size: 1.2rem;
    z-index: 10;
    display: none;
    text-align: center;
    min-width: 200px;
    max-width: 80%;
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.success {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(76, 175, 80, 0.9);
    color: white;
    padding: 1rem;
    border-radius: 1rem;
    font-size: 1.2rem;
    z-index: 10;
    display: none;
    text-align: center;
    min-width: 200px;
    max-width: 80%;
    backdrop-filter: blur(5px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    line-height: 1.5;
}

.floating-score {
    position: absolute;
    color: #4CAF50;
    font-weight: bold;
    font-size: 1.2rem;
    pointer-events: none;
    animation: floatUp 1s ease-out;
    opacity: 0;
}

.streak-multiplier {
    position: absolute;
    color: #2196F3;
    font-weight: bold;
    font-size: 1rem;
    pointer-events: none;
    animation: pulse 0.5s ease-out;
}

@keyframes floatUp {
    0% {
        transform: translateY(0);
        opacity: 1;
    }
    100% {
        transform: translateY(-50px);
        opacity: 0;
    }
}

/* Mobile Optimization */
@media (max-width: 768px) {
    .game-container {
        margin: 5rem auto 1rem;
        padding: 0.5rem;
    }
    
    .game-area {
        padding-bottom: 75%; /* Slightly taller on mobile */
    }
    
    .ball {
        width: 20px;
        height: 20px;
    }
    
    .game-info {
        font-size: 1rem;
    }
    
    .success, .game-over {
        font-size: 1rem;
        padding: 0.8rem;
        min-width: 180px;
        max-width: 90%;
    }
}

@media (max-width: 480px) {
    .game-container {
        margin: 4rem auto 1rem;
    }
    
    .game-area {
        padding-bottom: 80%; /* Even taller on small mobile */
    }
    
    .ball {
        width: 18px;
        height: 18px;
    }
    
    #startButton {
        padding: 10px 20px;
        font-size: 16px;
    }
    
    .success, .game-over {
        font-size: 0.9rem;
        padding: 0.7rem;
        min-width: 160px;
        max-width: 95%;
        line-height: 1.4;
    }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const gameArea = document.querySelector('.game-area');
    const ball = document.querySelector('.ball');
    const startButton = document.getElementById('startButton');
    const canvas = document.getElementById('trailCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const statusElement = document.getElementById('status');
    const timerElement = document.getElementById('timer');
    let timeLeft = 20;
    let timerInterval;
    let currentScore = 0;
    let streakMultiplier = 1;
    let lastCheckTime = 0;
    let smoothMovementPoints = 0;
    const SMOOTH_CHECK_INTERVAL = 100; // Check every 100ms

    // Set canvas size to match game area
    canvas.width = gameArea.offsetWidth;
    canvas.height = gameArea.offsetHeight;

    let isDragging = false;
    let startX, startY;
    let ballStartX, ballStartY;
    let lastX, lastY;
    let isGameActive = false;
    let hasReachedFinish = false;
    let lineY;
    let lineStartX;
    let lineEndX;
    let lineThickness = 24;
    let linePath = [];
    let linePoints = [];
    let currentLevel = 1;

    function getBallPosition() {
        const rect = ball.getBoundingClientRect();
        return {
            x: rect.left + rect.width / 2,
            y: rect.top + rect.height / 2
        };
    }

    function drawLine(startX, startY, endX, endY, color = '#4CAF50', width = 3) {
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        ctx.stroke();
    }

    function drawWaveLine() {
        if (linePath.length < 2) return;
        
        // Draw the main path
        ctx.beginPath();
        ctx.moveTo(linePath[0].x, linePath[0].y);
        
        for (let i = 1; i < linePath.length; i++) {
            const point = linePath[i];
            
            if (point.cp1x !== undefined) {
                ctx.bezierCurveTo(
                    point.cp1x, point.cp1y,
                    point.cp2x, point.cp2y,
                    point.x, point.y
                );
            } else {
                ctx.lineTo(point.x, point.y);
            }
        }
        
        ctx.strokeStyle = '#333';
        ctx.lineWidth = lineThickness;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.stroke();
        
        // Draw finish point (red circle) at the exact end of the line
        const lastPoint = linePoints[linePoints.length - 1];
        ctx.beginPath();
        ctx.arc(lastPoint.x, lastPoint.y, lineThickness * 0.75, 0, Math.PI * 2); // Scale finish point with line thickness
        ctx.fillStyle = '#f44336';
        ctx.fill();
        
        // Add text labels with adjusted positioning
        ctx.font = 'bold 16px Arial';
        ctx.fillStyle = '#333';
        ctx.textAlign = 'center';
        ctx.fillText('START', linePoints[0].x, linePoints[0].y - lineThickness * 1.5);
        ctx.fillText('FINISH', lastPoint.x, lastPoint.y - lineThickness * 1.5);
    }

    function showFloatingScore(points, x, y, color = '#4CAF50') {
        const floatingScore = document.createElement('div');
        floatingScore.className = 'floating-score';
        floatingScore.style.left = x + 'px';
        floatingScore.style.top = y + 'px';
        floatingScore.style.color = color;
        
        // Show + sign for positive points
        floatingScore.textContent = points >= 0 ? `+${points}` : points;
        
        gameArea.appendChild(floatingScore);
        
        // Remove the element after animation
        setTimeout(() => {
            floatingScore.remove();
        }, 1000);
    }
    
    function updateScore(points, x, y, color) {
        currentScore += points;
        scoreElement.textContent = `Score: ${currentScore}`;
        
        if (points !== 0) {
            showFloatingScore(points, x, y, color);
        }
    }

    function checkBallPosition() {
        if (!isGameActive) return;
        
        const pos = getBallPosition();
        const gameRect = gameArea.getBoundingClientRect();
        const ballX = pos.x - gameRect.left;
        const ballY = pos.y - gameRect.top;
        
        // Find the closest point on the path
        let closestPoint = null;
        let minDistance = Infinity;
        
        for (const point of linePoints) {
            const distance = Math.sqrt(
                Math.pow(ballX - point.x, 2) + 
                Math.pow(ballY - point.y, 2)
            );
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPoint = point;
            }
        }
        
        const now = Date.now();
        if (now - lastCheckTime >= SMOOTH_CHECK_INTERVAL) {
            // Check if movement is smooth (close to the line)
            if (minDistance <= lineThickness * 0.5) { // Increased tolerance for smooth movement
                smoothMovementPoints++;
                if (smoothMovementPoints % 5 === 0) {
                    streakMultiplier = Math.min(streakMultiplier + 0.1, 3.0);
                    const bonus = Math.round(2 * streakMultiplier);
                    updateScore(bonus, ballX, ballY - 20, '#2196F3');
                    
                    // Show multiplier
                    const multiplierDiv = document.createElement('div');
                    multiplierDiv.className = 'streak-multiplier';
                    multiplierDiv.textContent = `${streakMultiplier.toFixed(1)}x`;
                    multiplierDiv.style.left = (ballX + 20) + 'px';
                    multiplierDiv.style.top = (ballY - 20) + 'px';
                    gameArea.appendChild(multiplierDiv);
                    setTimeout(() => multiplierDiv.remove(), 500);
                }
            } else {
                // Reset streak if not moving smoothly
                streakMultiplier = Math.max(1, streakMultiplier - 0.2);
                smoothMovementPoints = 0;
            }
            
            lastCheckTime = now;
        }
        
        // Make collision detection more forgiving at higher levels
        const toleranceIncrease = Math.min(15, (currentLevel - 1) * 3); // Increased base tolerance and level scaling
        const tolerance = (lineThickness * 0.75) + toleranceIncrease; // Increased base tolerance multiplier
        
        // Check if ball is within the adjusted tolerance
        if (minDistance > tolerance) {
            gameOver("You went off the line!");
            return;
        }
        
        // Get the last point of the line
        const lastPoint = linePoints[linePoints.length - 1];
        
        // Calculate distance to finish point
        const distanceToFinish = Math.sqrt(
            Math.pow(ballX - lastPoint.x, 2) + 
            Math.pow(ballY - lastPoint.y, 2)
        );
        
        // Check if ball reached the finish line
        if (distanceToFinish <= tolerance && !hasReachedFinish) {
            hasReachedFinish = true;
            const finalMultiplier = Math.round(streakMultiplier * 10) / 10;
            const levelBonus = Math.round(currentLevel * 100 * finalMultiplier);
            const timeBonus = Math.round(timeLeft * 5 * finalMultiplier);
            
            success(`Level ${currentLevel} Complete!\nLevel Bonus: ${levelBonus}\nTime Bonus: ${timeBonus}\nStreak Multiplier: ${finalMultiplier}x`);
        }
    }

    function updateTimer() {
        timeLeft--;
        timerElement.textContent = `Time: ${timeLeft}s`;
        
        if (timeLeft <= 5) {
            timerElement.style.color = '#f44336'; // Red color for last 5 seconds
        }
        
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            gameOver("Time's up!");
        }
    }

    function gameOver(message) {
        isGameActive = false;
        isDragging = false;
        statusElement.textContent = message;
        statusElement.style.display = 'block';
        
        // Stop the timer
        clearInterval(timerInterval);
        
        // Create game over message
        const gameOverDiv = document.createElement('div');
        gameOverDiv.className = 'game-over';
        gameOverDiv.textContent = message;
        gameArea.appendChild(gameOverDiv);
        gameOverDiv.style.display = 'block';
        
        // Save score
        saveScore(0);
    }

    function calculateTimeBonus() {
        // Give bonus points for remaining time
        // More time left = more bonus points
        const timeBonus = timeLeft * 5; // 5 points per second remaining
        return timeBonus;
    }

    function success(message) {
        isGameActive = false;
        isDragging = false;
        
        // Calculate level completion bonus
        const levelBonus = currentLevel * 100;
        
        // Calculate time bonus
        const timeBonus = calculateTimeBonus();
        
        // Update total score
        const totalBonus = levelBonus + timeBonus;
        updateScore(totalBonus, 0, 0, '#4CAF50');
        
        // Create success message with more concise formatting
        const successDiv = document.createElement('div');
        successDiv.className = 'success';
        
        // Format the message with line breaks and spans for styling
        const formattedMessage = `
            <strong>Complete!</strong><br>
            Level Bonus: ${levelBonus}<br>
            Time Bonus: ${timeBonus}<br>
            Total Score: ${currentScore}
        `;
        
        successDiv.innerHTML = formattedMessage;
        gameArea.appendChild(successDiv);
        successDiv.style.display = 'block';
        
        // Update the start button for next level
        currentLevel++;
        startButton.textContent = `Level ${currentLevel}`;
        
        // Save score
        saveScore(totalBonus);
    }
    
    function saveScore(score) {
        // Send score to server
        fetch('/save_score', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                game_type: 'Line Balance Master',
                score: score,
                total: 100
            }),
        })
        .then(response => response.json())
        .then(data => console.log('Score saved:', data))
        .catch(error => console.error('Error saving score:', error));
    }

    function generateWavePath() {
        linePoints = [];
        linePath = [];
        
        // Set up the line boundaries
        const lineStartX = gameArea.offsetWidth * 0.1;  // 10% from the left
        const lineEndX = gameArea.offsetWidth * 0.9;    // 90% from the left
        const lineY = gameArea.offsetHeight * 0.5;      // Middle of the field
        
        // Calculate maximum safe amplitude based on game area height
        const maxAmplitude = (gameArea.offsetHeight * 0.35); // Use 35% of height as max amplitude
        
        // Start with a straight line for level 1
        if (currentLevel === 1) {
            // Generate points along the straight line for smooth collision detection
            for (let x = lineStartX; x <= lineEndX; x += 2) {
                linePoints.push({x, y: lineY});
            }
            linePath = linePoints;
            return;
        }
        
        // Calculate the path based on the current level
        let amplitude, frequency;
        
        if (currentLevel === 2) {
            // Gentle wave for level 2
            amplitude = Math.min(20, maxAmplitude * 0.3);
            frequency = 0.005;
        } else {
            // More complex waves for higher levels
            const baseAmplitude = 20 + ((currentLevel - 2) * 8);
            amplitude = Math.min(baseAmplitude, maxAmplitude);
            frequency = 0.005 + ((currentLevel - 2) * 0.003);
        }
        
        // Generate control points for smooth curve
        const points = [];
        const numPoints = Math.max(100, 50 + currentLevel * 10);
        const step = (lineEndX - lineStartX) / (numPoints - 1);
        
        for (let i = 0; i < numPoints; i++) {
            const x = lineStartX + (step * i);
            let y = lineY;
            
            if (currentLevel === 2) {
                // Simple sine wave for level 2
                y += Math.sin((x - lineStartX) * frequency) * amplitude;
            } else if (currentLevel >= 3) {
                // Composite wave pattern
                y += Math.sin((x - lineStartX) * frequency) * amplitude;
                y += Math.sin((x - lineStartX) * frequency * 2) * (amplitude * 0.3);
            }
            
            points.push({x, y});
        }
        
        // Ensure last point is exactly at lineEndX
        points[points.length - 1] = {
            x: lineEndX,
            y: points[points.length - 1].y
        };
        
        // Generate smooth curve through points
        linePath = [];
        linePoints = [];
        
        // Start with the first point
        linePath.push(points[0]);
        linePoints.push(points[0]);
        
        // Generate bezier curves through points
        for (let i = 1; i < points.length - 2; i++) {
            const p0 = points[i - 1];
            const p1 = points[i];
            const p2 = points[i + 1];
            const p3 = points[i + 2];
            
            // Generate more points along the curve for better collision detection
            for (let t = 0; t <= 1; t += 0.05) {
                const tt = t * t;
                const ttt = tt * t;
                
                const x = 0.5 * (
                    2 * p1.x +
                    (-p0.x + p2.x) * t +
                    (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * tt +
                    (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * ttt
                );
                
                const y = 0.5 * (
                    2 * p1.y +
                    (-p0.y + p2.y) * t +
                    (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * tt +
                    (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * ttt
                );
                
                linePoints.push({x, y});
            }
            
            // Add control points for drawing
            linePath.push({
                x: p2.x,
                y: p2.y,
                cp1x: (p1.x + p2.x) / 2,
                cp1y: p1.y,
                cp2x: (p1.x + p2.x) / 2,
                cp2y: p2.y
            });
        }
        
        // Add the final point
        linePath.push(points[points.length - 1]);
        linePoints.push(points[points.length - 1]);
    }

    function startGame() {
        // Clear the canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Remove any existing messages
        const existingMessages = document.querySelectorAll('.game-over, .success');
        existingMessages.forEach(msg => msg.remove());
        
        // Reset game state
        isGameActive = true;
        hasReachedFinish = false;
        statusElement.textContent = "";
        statusElement.style.display = 'none';
        
        // Update button text to show current level
        startButton.textContent = `Level ${currentLevel}`;
        
        // Reset and start timer
        clearInterval(timerInterval);
        timeLeft = 20;
        timerElement.textContent = `Time: ${timeLeft}s`;
        timerElement.style.color = '#2196F3';
        timerInterval = setInterval(updateTimer, 1000);
        
        // Generate and draw the line
        generateWavePath();
        drawWaveLine();
        
        // Position the ball exactly on the start of the line
        if (linePoints.length > 0) {
            const startPoint = linePoints[0];
            ball.style.left = startPoint.x + 'px';
            ball.style.top = startPoint.y + 'px';
            
            // Get initial ball position for line drawing
            const pos = getBallPosition();
            const gameRect = gameArea.getBoundingClientRect();
            lastX = pos.x - gameRect.left;
            lastY = pos.y - gameRect.top;
        }
        
        // Initialize score
        streakMultiplier = 1;
        smoothMovementPoints = 0;
        lastCheckTime = Date.now();
        updateScore(0, 0, 0, '#4CAF50');
    }

    // Initialize the game
    generateWavePath();
    drawWaveLine();
    
    // Position the ball on the line initially
    ball.style.left = '10%';
    ball.style.top = '50%';
    
    const pos = getBallPosition();
    const gameRect = gameArea.getBoundingClientRect();
    lastX = pos.x - gameRect.left;
    lastY = pos.y - gameRect.top;

    // Set initial button text to "Start Game"
    startButton.textContent = 'Start Game';

    startButton.addEventListener('click', startGame);

    // Add touch event handlers
    ball.addEventListener('touchstart', handleTouchStart, false);
    document.addEventListener('touchmove', handleTouchMove, false);
    document.addEventListener('touchend', handleTouchEnd, false);

    let touchStartX = 0;
    let touchStartY = 0;

    function handleTouchStart(e) {
        if (!isGameActive) return;
        e.preventDefault();
        
        isDragging = true;
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        
        // Get the ball's current position relative to the game area
        const ballRect = ball.getBoundingClientRect();
        const gameRect = gameArea.getBoundingClientRect();
        ballStartX = ballRect.left - gameRect.left;
        ballStartY = ballRect.top - gameRect.top;
        
        // Get initial ball position for line drawing
        const pos = getBallPosition();
        lastX = pos.x - gameArea.getBoundingClientRect().left;
        lastY = pos.y - gameArea.getBoundingClientRect().top;
    }

    function handleTouchMove(e) {
        if (!isDragging || !isGameActive) return;
        e.preventDefault();
        
        const touch = e.touches[0];
        const gameRect = gameArea.getBoundingClientRect();
        const dx = touch.clientX - touchStartX;
        const dy = touch.clientY - touchStartY;
        
        // Calculate new position
        let newX = ballStartX + dx;
        let newY = ballStartY + dy;
        
        // Keep ball within game area bounds
        const ballSize = ball.offsetWidth;
        newX = Math.max(ballSize/2, Math.min(newX, gameArea.offsetWidth - ballSize/2));
        newY = Math.max(ballSize/2, Math.min(newY, gameArea.offsetHeight - ballSize/2));
        
        // Update ball position
        ball.style.left = (newX * 100 / gameArea.offsetWidth) + '%';
        ball.style.top = (newY * 100 / gameArea.offsetHeight) + '%';
        
        // Draw line from last position to current position
        const pos = getBallPosition();
        const currentX = pos.x - gameRect.left;
        const currentY = pos.y - gameRect.top;
        drawLine(lastX, lastY, currentX, currentY);
        lastX = currentX;
        lastY = currentY;
        
        // Check if ball is still on the line
        checkBallPosition();
    }

    function handleTouchEnd() {
        isDragging = false;
    }

    // Mouse event handlers
    ball.addEventListener('mousedown', handleMouseStart, false);
    document.addEventListener('mousemove', handleMouseMove, false);
    document.addEventListener('mouseup', handleMouseEnd, false);

    function handleMouseStart(e) {
        if (!isGameActive) return;
        
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
        
        // Get the ball's current position relative to the game area
        const ballRect = ball.getBoundingClientRect();
        const gameRect = gameArea.getBoundingClientRect();
        ballStartX = ballRect.left - gameRect.left;
        ballStartY = ballRect.top - gameRect.top;
        
        // Get initial ball position for line drawing
        const pos = getBallPosition();
        lastX = pos.x - gameArea.getBoundingClientRect().left;
        lastY = pos.y - gameArea.getBoundingClientRect().top;
    }

    function handleMouseMove(e) {
        if (!isDragging || !isGameActive) return;
        
        const gameRect = gameArea.getBoundingClientRect();
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        // Calculate new position
        let newX = ballStartX + dx;
        let newY = ballStartY + dy;
        
        // Keep ball within game area bounds
        const ballSize = ball.offsetWidth;
        newX = Math.max(ballSize/2, Math.min(newX, gameArea.offsetWidth - ballSize/2));
        newY = Math.max(ballSize/2, Math.min(newY, gameArea.offsetHeight - ballSize/2));
        
        // Update ball position
        ball.style.left = (newX * 100 / gameArea.offsetWidth) + '%';
        ball.style.top = (newY * 100 / gameArea.offsetHeight) + '%';
        
        // Draw line from last position to current position
        const pos = getBallPosition();
        const currentX = pos.x - gameRect.left;
        const currentY = pos.y - gameRect.top;
        drawLine(lastX, lastY, currentX, currentY);
        lastX = currentX;
        lastY = currentY;
        
        // Check if ball is still on the line
        checkBallPosition();
    }

    function handleMouseEnd() {
        isDragging = false;
    }

    // Update canvas size when window resizes
    window.addEventListener('resize', function() {
        canvas.width = gameArea.offsetWidth;
        canvas.height = gameArea.offsetHeight;
        drawWaveLine();
    });
});
</script>
{% endblock %} 